// This file is auto-generated by kubernetes-fluent-client, do not edit manually
import { GenericKind, RegisterKind } from "kubernetes-fluent-client";
export class Tenant extends GenericKind {
  declare apiVersion?: string;
  declare kind?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  declare metadata?: { [key: string]: any };
  scheduler?: Scheduler;
  spec?: TenantSpec;
  status?: TenantStatus;
}

export interface Scheduler {
  name: string;
}

export interface TenantSpec {
  additionalVolumeMounts?: AdditionalVolumeMount[];
  additionalVolumes?: AdditionalVolume[];
  buckets?: Bucket[];
  certConfig?: CERTConfig;
  certExpiryAlertThreshold?: number;
  configuration?: Configuration;
  env?: SpecEnv[];
  exposeServices?: ExposeServices;
  externalCaCertSecret?: ExternalCACERTSecret[];
  externalCertSecret?: ExternalCERTSecretElement[];
  externalClientCertSecret?: PurpleExternalClientCERTSecret;
  externalClientCertSecrets?: ExternalClientCERTSecretElement[];
  features?: Features;
  image?: string;
  imagePullPolicy?: string;
  imagePullSecret?: ImagePullSecret;
  initContainers?: InitContainer[];
  kes?: Kes;
  lifecycle?: SpecLifecycle;
  liveness?: Liveness;
  logging?: Logging;
  mountPath?: string;
  podManagementPolicy?: string;
  pools: SpecPool[];
  poolsMetadata?: PoolsMetadata;
  priorityClassName?: string;
  prometheusOperator?: boolean;
  readiness?: Readiness;
  requestAutoCert?: boolean;
  serviceAccountName?: string;
  serviceMetadata?: ServiceMetadata;
  sideCars?: SideCars;
  startup?: Startup;
  subPath?: string;
  users?: User[];
}

export interface AdditionalVolumeMount {
  mountPath: string;
  mountPropagation?: string;
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
  subPath?: string;
  subPathExpr?: string;
}

export interface AdditionalVolume {
  awsElasticBlockStore?: AdditionalVolumeAwsElasticBlockStore;
  azureDisk?: AdditionalVolumeAzureDisk;
  azureFile?: AdditionalVolumeAzureFile;
  cephfs?: AdditionalVolumeCephfs;
  cinder?: AdditionalVolumeCinder;
  configMap?: AdditionalVolumeConfigMap;
  csi?: AdditionalVolumeCSI;
  downwardAPI?: AdditionalVolumeDownwardAPI;
  emptyDir?: AdditionalVolumeEmptyDir;
  ephemeral?: AdditionalVolumeEphemeral;
  fc?: AdditionalVolumeFc;
  flexVolume?: AdditionalVolumeFlexVolume;
  flocker?: AdditionalVolumeFlocker;
  gcePersistentDisk?: AdditionalVolumeGcePersistentDisk;
  gitRepo?: AdditionalVolumeGitRepo;
  glusterfs?: AdditionalVolumeGlusterfs;
  hostPath?: AdditionalVolumeHostPath;
  image?: AdditionalVolumeImage;
  iscsi?: AdditionalVolumeIscsi;
  name: string;
  nfs?: AdditionalVolumeNFS;
  persistentVolumeClaim?: AdditionalVolumePersistentVolumeClaim;
  photonPersistentDisk?: AdditionalVolumePhotonPersistentDisk;
  portworxVolume?: AdditionalVolumePortworxVolume;
  projected?: AdditionalVolumeProjected;
  quobyte?: AdditionalVolumeQuobyte;
  rbd?: AdditionalVolumeRbd;
  scaleIO?: AdditionalVolumeScaleIO;
  secret?: AdditionalVolumeSecret;
  storageos?: AdditionalVolumeStorageos;
  vsphereVolume?: AdditionalVolumeVsphereVolume;
}

export interface AdditionalVolumeAwsElasticBlockStore {
  fsType?: string;
  partition?: number;
  readOnly?: boolean;
  volumeID: string;
}

export interface AdditionalVolumeAzureDisk {
  cachingMode?: string;
  diskName: string;
  diskURI: string;
  fsType?: string;
  kind?: string;
  readOnly?: boolean;
}

export interface AdditionalVolumeAzureFile {
  readOnly?: boolean;
  secretName: string;
  shareName: string;
}

export interface AdditionalVolumeCephfs {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: PurpleSecretRef;
  user?: string;
}

export interface PurpleSecretRef {
  name?: string;
}

export interface AdditionalVolumeCinder {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: FluffySecretRef;
  volumeID: string;
}

export interface FluffySecretRef {
  name?: string;
}

export interface AdditionalVolumeConfigMap {
  defaultMode?: number;
  items?: PurpleItem[];
  name?: string;
  optional?: boolean;
}

export interface PurpleItem {
  key: string;
  mode?: number;
  path: string;
}

export interface AdditionalVolumeCSI {
  driver: string;
  fsType?: string;
  nodePublishSecretRef?: PurpleNodePublishSecretRef;
  readOnly?: boolean;
  volumeAttributes?: { [key: string]: string };
}

export interface PurpleNodePublishSecretRef {
  name?: string;
}

export interface AdditionalVolumeDownwardAPI {
  defaultMode?: number;
  items?: FluffyItem[];
}

export interface FluffyItem {
  fieldRef?: PurpleFieldRef;
  mode?: number;
  path: string;
  resourceFieldRef?: PurpleResourceFieldRef;
}

export interface PurpleFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface PurpleResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface AdditionalVolumeEmptyDir {
  medium?: string;
  sizeLimit?: number | string;
}

export interface AdditionalVolumeEphemeral {
  volumeClaimTemplate?: PurpleVolumeClaimTemplate;
}

export interface PurpleVolumeClaimTemplate {
  metadata?: PurpleMetadata;
  spec: PurpleSpec;
}

export interface PurpleMetadata {
  annotations?: { [key: string]: string };
  finalizers?: string[];
  labels?: { [key: string]: string };
  name?: string;
  namespace?: string;
}

export interface PurpleSpec {
  accessModes?: string[];
  dataSource?: PurpleDataSource;
  dataSourceRef?: PurpleDataSourceRef;
  resources?: PurpleResources;
  selector?: PurpleSelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: string;
  volumeName?: string;
}

export interface PurpleDataSource {
  apiGroup?: string;
  kind: string;
  name: string;
}

export interface PurpleDataSourceRef {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}

export interface PurpleResources {
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface PurpleSelector {
  matchExpressions?: PurpleMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface PurpleMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface AdditionalVolumeFc {
  fsType?: string;
  lun?: number;
  readOnly?: boolean;
  targetWWNs?: string[];
  wwids?: string[];
}

export interface AdditionalVolumeFlexVolume {
  driver: string;
  fsType?: string;
  options?: { [key: string]: string };
  readOnly?: boolean;
  secretRef?: TentacledSecretRef;
}

export interface TentacledSecretRef {
  name?: string;
}

export interface AdditionalVolumeFlocker {
  datasetName?: string;
  datasetUUID?: string;
}

export interface AdditionalVolumeGcePersistentDisk {
  fsType?: string;
  partition?: number;
  pdName: string;
  readOnly?: boolean;
}

export interface AdditionalVolumeGitRepo {
  directory?: string;
  repository: string;
  revision?: string;
}

export interface AdditionalVolumeGlusterfs {
  endpoints: string;
  path: string;
  readOnly?: boolean;
}

export interface AdditionalVolumeHostPath {
  path: string;
  type?: string;
}

export interface AdditionalVolumeImage {
  pullPolicy?: string;
  reference?: string;
}

export interface AdditionalVolumeIscsi {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: StickySecretRef;
  targetPortal: string;
}

export interface StickySecretRef {
  name?: string;
}

export interface AdditionalVolumeNFS {
  path: string;
  readOnly?: boolean;
  server: string;
}

export interface AdditionalVolumePersistentVolumeClaim {
  claimName: string;
  readOnly?: boolean;
}

export interface AdditionalVolumePhotonPersistentDisk {
  fsType?: string;
  pdID: string;
}

export interface AdditionalVolumePortworxVolume {
  fsType?: string;
  readOnly?: boolean;
  volumeID: string;
}

export interface AdditionalVolumeProjected {
  defaultMode?: number;
  sources?: PurpleSource[];
}

export interface PurpleSource {
  clusterTrustBundle?: PurpleClusterTrustBundle;
  configMap?: PurpleConfigMap;
  downwardAPI?: PurpleDownwardAPI;
  secret?: PurpleSecret;
  serviceAccountToken?: PurpleServiceAccountToken;
}

export interface PurpleClusterTrustBundle {
  labelSelector?: PurpleLabelSelector;
  name?: string;
  optional?: boolean;
  path: string;
  signerName?: string;
}

export interface PurpleLabelSelector {
  matchExpressions?: FluffyMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface FluffyMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurpleConfigMap {
  items?: TentacledItem[];
  name?: string;
  optional?: boolean;
}

export interface TentacledItem {
  key: string;
  mode?: number;
  path: string;
}

export interface PurpleDownwardAPI {
  items?: StickyItem[];
}

export interface StickyItem {
  fieldRef?: FluffyFieldRef;
  mode?: number;
  path: string;
  resourceFieldRef?: FluffyResourceFieldRef;
}

export interface FluffyFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface FluffyResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface PurpleSecret {
  items?: IndigoItem[];
  name?: string;
  optional?: boolean;
}

export interface IndigoItem {
  key: string;
  mode?: number;
  path: string;
}

export interface PurpleServiceAccountToken {
  audience?: string;
  expirationSeconds?: number;
  path: string;
}

export interface AdditionalVolumeQuobyte {
  group?: string;
  readOnly?: boolean;
  registry: string;
  tenant?: string;
  user?: string;
  volume: string;
}

export interface AdditionalVolumeRbd {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: IndigoSecretRef;
  user?: string;
}

export interface IndigoSecretRef {
  name?: string;
}

export interface AdditionalVolumeScaleIO {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: IndecentSecretRef;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}

export interface IndecentSecretRef {
  name?: string;
}

export interface AdditionalVolumeSecret {
  defaultMode?: number;
  items?: IndecentItem[];
  optional?: boolean;
  secretName?: string;
}

export interface IndecentItem {
  key: string;
  mode?: number;
  path: string;
}

export interface AdditionalVolumeStorageos {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: HilariousSecretRef;
  volumeName?: string;
  volumeNamespace?: string;
}

export interface HilariousSecretRef {
  name?: string;
}

export interface AdditionalVolumeVsphereVolume {
  fsType?: string;
  storagePolicyID?: string;
  storagePolicyName?: string;
  volumePath: string;
}

export interface Bucket {
  name?: string;
  objectLock?: boolean;
  region?: string;
}

export interface CERTConfig {
  commonName?: string;
  dnsNames?: string[];
  organizationName?: string[];
}

export interface Configuration {
  name?: string;
}

export interface SpecEnv {
  name: string;
  value?: string;
  valueFrom?: PurpleValueFrom;
}

export interface PurpleValueFrom {
  configMapKeyRef?: PurpleConfigMapKeyRef;
  fieldRef?: TentacledFieldRef;
  resourceFieldRef?: TentacledResourceFieldRef;
  secretKeyRef?: PurpleSecretKeyRef;
}

export interface PurpleConfigMapKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface TentacledFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface TentacledResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface PurpleSecretKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface ExposeServices {
  console?: boolean;
  minio?: boolean;
}

export interface ExternalCACERTSecret {
  name: string;
  type?: string;
}

export interface ExternalCERTSecretElement {
  name: string;
  type?: string;
}

export interface PurpleExternalClientCERTSecret {
  name: string;
  type?: string;
}

export interface ExternalClientCERTSecretElement {
  name: string;
  type?: string;
}

export interface Features {
  bucketDNS?: boolean;
  domains?: Domains;
  enableSFTP?: boolean;
}

export interface Domains {
  console?: string;
  minio?: string[];
}

export interface ImagePullSecret {
  name?: string;
}

export interface InitContainer {
  args?: string[];
  command?: string[];
  env?: InitContainerEnv[];
  envFrom?: InitContainerEnvFrom[];
  image?: string;
  imagePullPolicy?: string;
  lifecycle?: InitContainerLifecycle;
  livenessProbe?: InitContainerLivenessProbe;
  name: string;
  ports?: InitContainerPort[];
  readinessProbe?: InitContainerReadinessProbe;
  resizePolicy?: InitContainerResizePolicy[];
  resources?: InitContainerResources;
  restartPolicy?: string;
  securityContext?: InitContainerSecurityContext;
  startupProbe?: InitContainerStartupProbe;
  stdin?: boolean;
  stdinOnce?: boolean;
  terminationMessagePath?: string;
  terminationMessagePolicy?: string;
  tty?: boolean;
  volumeDevices?: InitContainerVolumeDevice[];
  volumeMounts?: InitContainerVolumeMount[];
  workingDir?: string;
}

export interface InitContainerEnv {
  name: string;
  value?: string;
  valueFrom?: FluffyValueFrom;
}

export interface FluffyValueFrom {
  configMapKeyRef?: FluffyConfigMapKeyRef;
  fieldRef?: StickyFieldRef;
  resourceFieldRef?: StickyResourceFieldRef;
  secretKeyRef?: FluffySecretKeyRef;
}

export interface FluffyConfigMapKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface StickyFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface StickyResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface FluffySecretKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface InitContainerEnvFrom {
  configMapRef?: PurpleConfigMapRef;
  prefix?: string;
  secretRef?: AmbitiousSecretRef;
}

export interface PurpleConfigMapRef {
  name?: string;
  optional?: boolean;
}

export interface AmbitiousSecretRef {
  name?: string;
  optional?: boolean;
}

export interface InitContainerLifecycle {
  postStart?: PurplePostStart;
  preStop?: PurplePreStop;
}

export interface PurplePostStart {
  exec?: PurpleExec;
  httpGet?: PurpleHTTPGet;
  sleep?: PurpleSleep;
  tcpSocket?: PurpleTCPSocket;
}

export interface PurpleExec {
  command?: string[];
}

export interface PurpleHTTPGet {
  host?: string;
  httpHeaders?: PurpleHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface PurpleHTTPHeader {
  name: string;
  value: string;
}

export interface PurpleSleep {
  seconds: number;
}

export interface PurpleTCPSocket {
  host?: string;
  port: number | string;
}

export interface PurplePreStop {
  exec?: FluffyExec;
  httpGet?: FluffyHTTPGet;
  sleep?: FluffySleep;
  tcpSocket?: FluffyTCPSocket;
}

export interface FluffyExec {
  command?: string[];
}

export interface FluffyHTTPGet {
  host?: string;
  httpHeaders?: FluffyHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface FluffyHTTPHeader {
  name: string;
  value: string;
}

export interface FluffySleep {
  seconds: number;
}

export interface FluffyTCPSocket {
  host?: string;
  port: number | string;
}

export interface InitContainerLivenessProbe {
  exec?: TentacledExec;
  failureThreshold?: number;
  grpc?: PurpleGrpc;
  httpGet?: TentacledHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: TentacledTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface TentacledExec {
  command?: string[];
}

export interface PurpleGrpc {
  port: number;
  service?: string;
}

export interface TentacledHTTPGet {
  host?: string;
  httpHeaders?: TentacledHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface TentacledHTTPHeader {
  name: string;
  value: string;
}

export interface TentacledTCPSocket {
  host?: string;
  port: number | string;
}

export interface InitContainerPort {
  containerPort: number;
  hostIP?: string;
  hostPort?: number;
  name?: string;
  protocol?: string;
}

export interface InitContainerReadinessProbe {
  exec?: StickyExec;
  failureThreshold?: number;
  grpc?: FluffyGrpc;
  httpGet?: StickyHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: StickyTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface StickyExec {
  command?: string[];
}

export interface FluffyGrpc {
  port: number;
  service?: string;
}

export interface StickyHTTPGet {
  host?: string;
  httpHeaders?: StickyHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface StickyHTTPHeader {
  name: string;
  value: string;
}

export interface StickyTCPSocket {
  host?: string;
  port: number | string;
}

export interface InitContainerResizePolicy {
  resourceName: string;
  restartPolicy: string;
}

export interface InitContainerResources {
  claims?: PurpleClaim[];
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface PurpleClaim {
  name: string;
  request?: string;
}

export interface InitContainerSecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: PurpleAppArmorProfile;
  capabilities?: PurpleCapabilities;
  privileged?: boolean;
  procMount?: string;
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: PurpleSeccompProfile;
  seLinuxOptions?: PurpleSELinuxOptions;
  windowsOptions?: PurpleWindowsOptions;
}

export interface PurpleAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface PurpleCapabilities {
  add?: string[];
  drop?: string[];
}

export interface PurpleSELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface PurpleSeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface PurpleWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface InitContainerStartupProbe {
  exec?: IndigoExec;
  failureThreshold?: number;
  grpc?: TentacledGrpc;
  httpGet?: IndigoHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: IndigoTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface IndigoExec {
  command?: string[];
}

export interface TentacledGrpc {
  port: number;
  service?: string;
}

export interface IndigoHTTPGet {
  host?: string;
  httpHeaders?: IndigoHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface IndigoHTTPHeader {
  name: string;
  value: string;
}

export interface IndigoTCPSocket {
  host?: string;
  port: number | string;
}

export interface InitContainerVolumeDevice {
  devicePath: string;
  name: string;
}

export interface InitContainerVolumeMount {
  mountPath: string;
  mountPropagation?: string;
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
  subPath?: string;
  subPathExpr?: string;
}

export interface Kes {
  affinity?: KesAffinity;
  annotations?: { [key: string]: string };
  clientCertSecret?: ClientCERTSecret;
  containerSecurityContext?: KesContainerSecurityContext;
  env?: KesEnv[];
  externalCertSecret?: KesExternalCERTSecret;
  gcpCredentialSecretName?: string;
  gcpWorkloadIdentityPool?: string;
  image?: string;
  imagePullPolicy?: string;
  kesSecret: KesSecret;
  keyName?: string;
  labels?: { [key: string]: string };
  nodeSelector?: { [key: string]: string };
  replicas?: number;
  resources?: KesResources;
  securityContext?: KesSecurityContext;
  serviceAccountName?: string;
  tolerations?: KesToleration[];
  topologySpreadConstraints?: KesTopologySpreadConstraint[];
}

export interface KesAffinity {
  nodeAffinity?: PurpleNodeAffinity;
  podAffinity?: PurplePodAffinity;
  podAntiAffinity?: PurplePodAntiAffinity;
}

export interface PurpleNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: PurplePreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: PurpleRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface PurplePreferredDuringSchedulingIgnoredDuringExecution {
  preference: PurplePreference;
  weight: number;
}

export interface PurplePreference {
  matchExpressions?: TentacledMatchExpression[];
  matchFields?: PurpleMatchField[];
}

export interface TentacledMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurpleMatchField {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurpleRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: PurpleNodeSelectorTerm[];
}

export interface PurpleNodeSelectorTerm {
  matchExpressions?: StickyMatchExpression[];
  matchFields?: FluffyMatchField[];
}

export interface StickyMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyMatchField {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurplePodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: FluffyPreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: FluffyRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface FluffyPreferredDuringSchedulingIgnoredDuringExecution {
  podAffinityTerm: PurplePodAffinityTerm;
  weight: number;
}

export interface PurplePodAffinityTerm {
  labelSelector?: FluffyLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: PurpleNamespaceSelector;
  topologyKey: string;
}

export interface FluffyLabelSelector {
  matchExpressions?: IndigoMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface IndigoMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurpleNamespaceSelector {
  matchExpressions?: IndecentMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface IndecentMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyRequiredDuringSchedulingIgnoredDuringExecution {
  labelSelector?: TentacledLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: FluffyNamespaceSelector;
  topologyKey: string;
}

export interface TentacledLabelSelector {
  matchExpressions?: HilariousMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface HilariousMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyNamespaceSelector {
  matchExpressions?: AmbitiousMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface AmbitiousMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurplePodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: TentacledPreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: TentacledRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface TentacledPreferredDuringSchedulingIgnoredDuringExecution {
  podAffinityTerm: FluffyPodAffinityTerm;
  weight: number;
}

export interface FluffyPodAffinityTerm {
  labelSelector?: StickyLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: TentacledNamespaceSelector;
  topologyKey: string;
}

export interface StickyLabelSelector {
  matchExpressions?: CunningMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface CunningMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface TentacledNamespaceSelector {
  matchExpressions?: MagentaMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface MagentaMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface TentacledRequiredDuringSchedulingIgnoredDuringExecution {
  labelSelector?: IndigoLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: StickyNamespaceSelector;
  topologyKey: string;
}

export interface IndigoLabelSelector {
  matchExpressions?: FriskyMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface FriskyMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface StickyNamespaceSelector {
  matchExpressions?: MischievousMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface MischievousMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface ClientCERTSecret {
  name: string;
  type?: string;
}

export interface KesContainerSecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: FluffyAppArmorProfile;
  capabilities?: FluffyCapabilities;
  privileged?: boolean;
  procMount?: string;
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: FluffySeccompProfile;
  seLinuxOptions?: FluffySELinuxOptions;
  windowsOptions?: FluffyWindowsOptions;
}

export interface FluffyAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface FluffyCapabilities {
  add?: string[];
  drop?: string[];
}

export interface FluffySELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface FluffySeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface FluffyWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface KesEnv {
  name: string;
  value?: string;
  valueFrom?: TentacledValueFrom;
}

export interface TentacledValueFrom {
  configMapKeyRef?: TentacledConfigMapKeyRef;
  fieldRef?: IndigoFieldRef;
  resourceFieldRef?: IndigoResourceFieldRef;
  secretKeyRef?: TentacledSecretKeyRef;
}

export interface TentacledConfigMapKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface IndigoFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface IndigoResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface TentacledSecretKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface KesExternalCERTSecret {
  name: string;
  type?: string;
}

export interface KesSecret {
  name?: string;
}

export interface KesResources {
  claims?: FluffyClaim[];
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface FluffyClaim {
  name: string;
  request?: string;
}

export interface KesSecurityContext {
  appArmorProfile?: TentacledAppArmorProfile;
  fsGroup?: number;
  fsGroupChangePolicy?: string;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: TentacledSeccompProfile;
  seLinuxOptions?: TentacledSELinuxOptions;
  supplementalGroups?: number[];
  supplementalGroupsPolicy?: string;
  sysctls?: PurpleSysctl[];
  windowsOptions?: TentacledWindowsOptions;
}

export interface TentacledAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface TentacledSELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface TentacledSeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface PurpleSysctl {
  name: string;
  value: string;
}

export interface TentacledWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface KesToleration {
  effect?: string;
  key?: string;
  operator?: string;
  tolerationSeconds?: number;
  value?: string;
}

export interface KesTopologySpreadConstraint {
  labelSelector?: IndecentLabelSelector;
  matchLabelKeys?: string[];
  maxSkew: number;
  minDomains?: number;
  nodeAffinityPolicy?: string;
  nodeTaintsPolicy?: string;
  topologyKey: string;
  whenUnsatisfiable: string;
}

export interface IndecentLabelSelector {
  matchExpressions?: BraggadociousMatchExpression[];
  matchLabels?: { [key: string]: string };
}

export interface BraggadociousMatchExpression {
  key: string;
  operator: string;
  values?: string[];
}

export interface SpecLifecycle {
  postStart?: FluffyPostStart;
  preStop?: FluffyPreStop;
}

export interface FluffyPostStart {
  exec?: IndecentExec;
  httpGet?: IndecentHTTPGet;
  sleep?: TentacledSleep;
  tcpSocket?: IndecentTCPSocket;
}

export interface IndecentExec {
  command?: string[];
}

export interface IndecentHTTPGet {
  host?: string;
  httpHeaders?: IndecentHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface IndecentHTTPHeader {
  name: string;
  value: string;
}

export interface TentacledSleep {
  seconds: number;
}

export interface IndecentTCPSocket {
  host?: string;
  port: number | string;
}

export interface FluffyPreStop {
  exec?: HilariousExec;
  httpGet?: HilariousHTTPGet;
  sleep?: StickySleep;
  tcpSocket?: HilariousTCPSocket;
}

export interface HilariousExec {
  command?: string[];
}

export interface HilariousHTTPGet {
  host?: string;
  httpHeaders?: HilariousHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface HilariousHTTPHeader {
  name: string;
  value: string;
}

export interface StickySleep {
  seconds: number;
}

export interface HilariousTCPSocket {
  host?: string;
  port: number | string;
}

export interface Liveness {
  exec?: LivenessExec;
  failureThreshold?: number;
  grpc?: LivenessGrpc;
  httpGet?: LivenessHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: LivenessTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface LivenessExec {
  command?: string[];
}

export interface LivenessGrpc {
  port: number;
  service?: string;
}

export interface LivenessHTTPGet {
  host?: string;
  httpHeaders?: AmbitiousHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface AmbitiousHTTPHeader {
  name: string;
  value: string;
}

export interface LivenessTCPSocket {
  host?: string;
  port: number | string;
}

export interface Logging {
  anonymous?: boolean;
  json?: boolean;
  quiet?: boolean;
}

export interface SpecPool {
  affinity?: PoolAffinity;
  annotations?: { [key: string]: string };
  containerSecurityContext?: PoolContainerSecurityContext;
  labels?: { [key: string]: string };
  name: string;
  nodeSelector?: { [key: string]: string };
  resources?: PoolResources;
  runtimeClassName?: string;
  securityContext?: PoolSecurityContext;
  servers: number;
  tolerations?: PoolToleration[];
  topologySpreadConstraints?: PoolTopologySpreadConstraint[];
  volumeClaimTemplate: PoolVolumeClaimTemplate;
  volumesPerServer: number;
}

export interface PoolAffinity {
  nodeAffinity?: FluffyNodeAffinity;
  podAffinity?: FluffyPodAffinity;
  podAntiAffinity?: FluffyPodAntiAffinity;
}

export interface FluffyNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: StickyPreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: StickyRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface StickyPreferredDuringSchedulingIgnoredDuringExecution {
  preference: FluffyPreference;
  weight: number;
}

export interface FluffyPreference {
  matchExpressions?: MatchExpression1[];
  matchFields?: TentacledMatchField[];
}

export interface MatchExpression1 {
  key: string;
  operator: string;
  values?: string[];
}

export interface TentacledMatchField {
  key: string;
  operator: string;
  values?: string[];
}

export interface StickyRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: FluffyNodeSelectorTerm[];
}

export interface FluffyNodeSelectorTerm {
  matchExpressions?: MatchExpression2[];
  matchFields?: StickyMatchField[];
}

export interface MatchExpression2 {
  key: string;
  operator: string;
  values?: string[];
}

export interface StickyMatchField {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: IndigoPreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: IndigoRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface IndigoPreferredDuringSchedulingIgnoredDuringExecution {
  podAffinityTerm: TentacledPodAffinityTerm;
  weight: number;
}

export interface TentacledPodAffinityTerm {
  labelSelector?: HilariousLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: IndigoNamespaceSelector;
  topologyKey: string;
}

export interface HilariousLabelSelector {
  matchExpressions?: MatchExpression3[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression3 {
  key: string;
  operator: string;
  values?: string[];
}

export interface IndigoNamespaceSelector {
  matchExpressions?: MatchExpression4[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression4 {
  key: string;
  operator: string;
  values?: string[];
}

export interface IndigoRequiredDuringSchedulingIgnoredDuringExecution {
  labelSelector?: AmbitiousLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: IndecentNamespaceSelector;
  topologyKey: string;
}

export interface AmbitiousLabelSelector {
  matchExpressions?: MatchExpression5[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression5 {
  key: string;
  operator: string;
  values?: string[];
}

export interface IndecentNamespaceSelector {
  matchExpressions?: MatchExpression6[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression6 {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: IndecentPreferredDuringSchedulingIgnoredDuringExecution[];
  requiredDuringSchedulingIgnoredDuringExecution?: IndecentRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface IndecentPreferredDuringSchedulingIgnoredDuringExecution {
  podAffinityTerm: StickyPodAffinityTerm;
  weight: number;
}

export interface StickyPodAffinityTerm {
  labelSelector?: CunningLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: HilariousNamespaceSelector;
  topologyKey: string;
}

export interface CunningLabelSelector {
  matchExpressions?: MatchExpression7[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression7 {
  key: string;
  operator: string;
  values?: string[];
}

export interface HilariousNamespaceSelector {
  matchExpressions?: MatchExpression8[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression8 {
  key: string;
  operator: string;
  values?: string[];
}

export interface IndecentRequiredDuringSchedulingIgnoredDuringExecution {
  labelSelector?: MagentaLabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaces?: string[];
  namespaceSelector?: AmbitiousNamespaceSelector;
  topologyKey: string;
}

export interface MagentaLabelSelector {
  matchExpressions?: MatchExpression9[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression9 {
  key: string;
  operator: string;
  values?: string[];
}

export interface AmbitiousNamespaceSelector {
  matchExpressions?: MatchExpression10[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression10 {
  key: string;
  operator: string;
  values?: string[];
}

export interface PoolContainerSecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: StickyAppArmorProfile;
  capabilities?: TentacledCapabilities;
  privileged?: boolean;
  procMount?: string;
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: StickySeccompProfile;
  seLinuxOptions?: StickySELinuxOptions;
  windowsOptions?: StickyWindowsOptions;
}

export interface StickyAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface TentacledCapabilities {
  add?: string[];
  drop?: string[];
}

export interface StickySELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface StickySeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface StickyWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface PoolResources {
  claims?: TentacledClaim[];
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface TentacledClaim {
  name: string;
  request?: string;
}

export interface PoolSecurityContext {
  appArmorProfile?: IndigoAppArmorProfile;
  fsGroup?: number;
  fsGroupChangePolicy?: string;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: IndigoSeccompProfile;
  seLinuxOptions?: IndigoSELinuxOptions;
  supplementalGroups?: number[];
  supplementalGroupsPolicy?: string;
  sysctls?: FluffySysctl[];
  windowsOptions?: IndigoWindowsOptions;
}

export interface IndigoAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface IndigoSELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface IndigoSeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface FluffySysctl {
  name: string;
  value: string;
}

export interface IndigoWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface PoolToleration {
  effect?: string;
  key?: string;
  operator?: string;
  tolerationSeconds?: number;
  value?: string;
}

export interface PoolTopologySpreadConstraint {
  labelSelector?: FriskyLabelSelector;
  matchLabelKeys?: string[];
  maxSkew: number;
  minDomains?: number;
  nodeAffinityPolicy?: string;
  nodeTaintsPolicy?: string;
  topologyKey: string;
  whenUnsatisfiable: string;
}

export interface FriskyLabelSelector {
  matchExpressions?: MatchExpression11[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression11 {
  key: string;
  operator: string;
  values?: string[];
}

export interface PoolVolumeClaimTemplate {
  apiVersion?: string;
  kind?: string;
  metadata?: FluffyMetadata;
  spec?: FluffySpec;
  status?: PurpleStatus;
}

export interface FluffyMetadata {
  annotations?: { [key: string]: string };
  finalizers?: string[];
  labels?: { [key: string]: string };
  name?: string;
  namespace?: string;
}

export interface FluffySpec {
  accessModes?: string[];
  dataSource?: FluffyDataSource;
  dataSourceRef?: FluffyDataSourceRef;
  resources?: FluffyResources;
  selector?: FluffySelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: string;
  volumeName?: string;
}

export interface FluffyDataSource {
  apiGroup?: string;
  kind: string;
  name: string;
}

export interface FluffyDataSourceRef {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}

export interface FluffyResources {
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface FluffySelector {
  matchExpressions?: MatchExpression12[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression12 {
  key: string;
  operator: string;
  values?: string[];
}

export interface PurpleStatus {
  accessModes?: string[];
  allocatedResources?: { [key: string]: number | string };
  allocatedResourceStatuses?: { [key: string]: string };
  capacity?: { [key: string]: number | string };
  conditions?: PurpleCondition[];
  currentVolumeAttributesClassName?: string;
  modifyVolumeStatus?: PurpleModifyVolumeStatus;
  phase?: string;
}

export interface PurpleCondition {
  lastProbeTime?: Date;
  lastTransitionTime?: Date;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}

export interface PurpleModifyVolumeStatus {
  status: string;
  targetVolumeAttributesClassName?: string;
}

export interface PoolsMetadata {
  annotations?: { [key: string]: string };
  labels?: { [key: string]: string };
}

export interface Readiness {
  exec?: ReadinessExec;
  failureThreshold?: number;
  grpc?: ReadinessGrpc;
  httpGet?: ReadinessHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: ReadinessTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface ReadinessExec {
  command?: string[];
}

export interface ReadinessGrpc {
  port: number;
  service?: string;
}

export interface ReadinessHTTPGet {
  host?: string;
  httpHeaders?: CunningHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface CunningHTTPHeader {
  name: string;
  value: string;
}

export interface ReadinessTCPSocket {
  host?: string;
  port: number | string;
}

export interface ServiceMetadata {
  consoleServiceAnnotations?: { [key: string]: string };
  consoleServiceLabels?: { [key: string]: string };
  kesServiceAnnotations?: { [key: string]: string };
  kesServiceLabels?: { [key: string]: string };
  minioServiceAnnotations?: { [key: string]: string };
  minioServiceLabels?: { [key: string]: string };
}

export interface SideCars {
  containers?: Container[];
  resources?: SideCarsResources;
  volumeClaimTemplates?: VolumeClaimTemplateElement[];
  volumes?: Volume[];
}

export interface Container {
  args?: string[];
  command?: string[];
  env?: ContainerEnv[];
  envFrom?: ContainerEnvFrom[];
  image?: string;
  imagePullPolicy?: string;
  lifecycle?: ContainerLifecycle;
  livenessProbe?: ContainerLivenessProbe;
  name: string;
  ports?: ContainerPort[];
  readinessProbe?: ContainerReadinessProbe;
  resizePolicy?: ContainerResizePolicy[];
  resources?: ContainerResources;
  restartPolicy?: string;
  securityContext?: ContainerSecurityContext;
  startupProbe?: ContainerStartupProbe;
  stdin?: boolean;
  stdinOnce?: boolean;
  terminationMessagePath?: string;
  terminationMessagePolicy?: string;
  tty?: boolean;
  volumeDevices?: ContainerVolumeDevice[];
  volumeMounts?: ContainerVolumeMount[];
  workingDir?: string;
}

export interface ContainerEnv {
  name: string;
  value?: string;
  valueFrom?: StickyValueFrom;
}

export interface StickyValueFrom {
  configMapKeyRef?: StickyConfigMapKeyRef;
  fieldRef?: IndecentFieldRef;
  resourceFieldRef?: IndecentResourceFieldRef;
  secretKeyRef?: StickySecretKeyRef;
}

export interface StickyConfigMapKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface IndecentFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface IndecentResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface StickySecretKeyRef {
  key: string;
  name?: string;
  optional?: boolean;
}

export interface ContainerEnvFrom {
  configMapRef?: FluffyConfigMapRef;
  prefix?: string;
  secretRef?: CunningSecretRef;
}

export interface FluffyConfigMapRef {
  name?: string;
  optional?: boolean;
}

export interface CunningSecretRef {
  name?: string;
  optional?: boolean;
}

export interface ContainerLifecycle {
  postStart?: TentacledPostStart;
  preStop?: TentacledPreStop;
}

export interface TentacledPostStart {
  exec?: AmbitiousExec;
  httpGet?: AmbitiousHTTPGet;
  sleep?: IndigoSleep;
  tcpSocket?: AmbitiousTCPSocket;
}

export interface AmbitiousExec {
  command?: string[];
}

export interface AmbitiousHTTPGet {
  host?: string;
  httpHeaders?: MagentaHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface MagentaHTTPHeader {
  name: string;
  value: string;
}

export interface IndigoSleep {
  seconds: number;
}

export interface AmbitiousTCPSocket {
  host?: string;
  port: number | string;
}

export interface TentacledPreStop {
  exec?: CunningExec;
  httpGet?: CunningHTTPGet;
  sleep?: IndecentSleep;
  tcpSocket?: CunningTCPSocket;
}

export interface CunningExec {
  command?: string[];
}

export interface CunningHTTPGet {
  host?: string;
  httpHeaders?: FriskyHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface FriskyHTTPHeader {
  name: string;
  value: string;
}

export interface IndecentSleep {
  seconds: number;
}

export interface CunningTCPSocket {
  host?: string;
  port: number | string;
}

export interface ContainerLivenessProbe {
  exec?: MagentaExec;
  failureThreshold?: number;
  grpc?: StickyGrpc;
  httpGet?: MagentaHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: MagentaTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface MagentaExec {
  command?: string[];
}

export interface StickyGrpc {
  port: number;
  service?: string;
}

export interface MagentaHTTPGet {
  host?: string;
  httpHeaders?: MischievousHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface MischievousHTTPHeader {
  name: string;
  value: string;
}

export interface MagentaTCPSocket {
  host?: string;
  port: number | string;
}

export interface ContainerPort {
  containerPort: number;
  hostIP?: string;
  hostPort?: number;
  name?: string;
  protocol?: string;
}

export interface ContainerReadinessProbe {
  exec?: FriskyExec;
  failureThreshold?: number;
  grpc?: IndigoGrpc;
  httpGet?: FriskyHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: FriskyTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface FriskyExec {
  command?: string[];
}

export interface IndigoGrpc {
  port: number;
  service?: string;
}

export interface FriskyHTTPGet {
  host?: string;
  httpHeaders?: BraggadociousHTTPHeader[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface BraggadociousHTTPHeader {
  name: string;
  value: string;
}

export interface FriskyTCPSocket {
  host?: string;
  port: number | string;
}

export interface ContainerResizePolicy {
  resourceName: string;
  restartPolicy: string;
}

export interface ContainerResources {
  claims?: StickyClaim[];
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface StickyClaim {
  name: string;
  request?: string;
}

export interface ContainerSecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: IndecentAppArmorProfile;
  capabilities?: StickyCapabilities;
  privileged?: boolean;
  procMount?: string;
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seccompProfile?: IndecentSeccompProfile;
  seLinuxOptions?: IndecentSELinuxOptions;
  windowsOptions?: IndecentWindowsOptions;
}

export interface IndecentAppArmorProfile {
  localhostProfile?: string;
  type: string;
}

export interface StickyCapabilities {
  add?: string[];
  drop?: string[];
}

export interface IndecentSELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface IndecentSeccompProfile {
  localhostProfile?: string;
  type: string;
}

export interface IndecentWindowsOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}

export interface ContainerStartupProbe {
  exec?: MischievousExec;
  failureThreshold?: number;
  grpc?: IndecentGrpc;
  httpGet?: MischievousHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: MischievousTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface MischievousExec {
  command?: string[];
}

export interface IndecentGrpc {
  port: number;
  service?: string;
}

export interface MischievousHTTPGet {
  host?: string;
  httpHeaders?: HTTPHeader1[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface HTTPHeader1 {
  name: string;
  value: string;
}

export interface MischievousTCPSocket {
  host?: string;
  port: number | string;
}

export interface ContainerVolumeDevice {
  devicePath: string;
  name: string;
}

export interface ContainerVolumeMount {
  mountPath: string;
  mountPropagation?: string;
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
  subPath?: string;
  subPathExpr?: string;
}

export interface SideCarsResources {
  claims?: IndigoClaim[];
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface IndigoClaim {
  name: string;
  request?: string;
}

export interface VolumeClaimTemplateElement {
  apiVersion?: string;
  kind?: string;
  metadata?: TentacledMetadata;
  spec?: TentacledSpec;
  status?: FluffyStatus;
}

export interface TentacledMetadata {
  annotations?: { [key: string]: string };
  finalizers?: string[];
  labels?: { [key: string]: string };
  name?: string;
  namespace?: string;
}

export interface TentacledSpec {
  accessModes?: string[];
  dataSource?: TentacledDataSource;
  dataSourceRef?: TentacledDataSourceRef;
  resources?: TentacledResources;
  selector?: TentacledSelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: string;
  volumeName?: string;
}

export interface TentacledDataSource {
  apiGroup?: string;
  kind: string;
  name: string;
}

export interface TentacledDataSourceRef {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}

export interface TentacledResources {
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface TentacledSelector {
  matchExpressions?: MatchExpression13[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression13 {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyStatus {
  accessModes?: string[];
  allocatedResources?: { [key: string]: number | string };
  allocatedResourceStatuses?: { [key: string]: string };
  capacity?: { [key: string]: number | string };
  conditions?: FluffyCondition[];
  currentVolumeAttributesClassName?: string;
  modifyVolumeStatus?: FluffyModifyVolumeStatus;
  phase?: string;
}

export interface FluffyCondition {
  lastProbeTime?: Date;
  lastTransitionTime?: Date;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}

export interface FluffyModifyVolumeStatus {
  status: string;
  targetVolumeAttributesClassName?: string;
}

export interface Volume {
  awsElasticBlockStore?: VolumeAwsElasticBlockStore;
  azureDisk?: VolumeAzureDisk;
  azureFile?: VolumeAzureFile;
  cephfs?: VolumeCephfs;
  cinder?: VolumeCinder;
  configMap?: VolumeConfigMap;
  csi?: VolumeCSI;
  downwardAPI?: VolumeDownwardAPI;
  emptyDir?: VolumeEmptyDir;
  ephemeral?: VolumeEphemeral;
  fc?: VolumeFc;
  flexVolume?: VolumeFlexVolume;
  flocker?: VolumeFlocker;
  gcePersistentDisk?: VolumeGcePersistentDisk;
  gitRepo?: VolumeGitRepo;
  glusterfs?: VolumeGlusterfs;
  hostPath?: VolumeHostPath;
  image?: VolumeImage;
  iscsi?: VolumeIscsi;
  name: string;
  nfs?: VolumeNFS;
  persistentVolumeClaim?: VolumePersistentVolumeClaim;
  photonPersistentDisk?: VolumePhotonPersistentDisk;
  portworxVolume?: VolumePortworxVolume;
  projected?: VolumeProjected;
  quobyte?: VolumeQuobyte;
  rbd?: VolumeRbd;
  scaleIO?: VolumeScaleIO;
  secret?: VolumeSecret;
  storageos?: VolumeStorageos;
  vsphereVolume?: VolumeVsphereVolume;
}

export interface VolumeAwsElasticBlockStore {
  fsType?: string;
  partition?: number;
  readOnly?: boolean;
  volumeID: string;
}

export interface VolumeAzureDisk {
  cachingMode?: string;
  diskName: string;
  diskURI: string;
  fsType?: string;
  kind?: string;
  readOnly?: boolean;
}

export interface VolumeAzureFile {
  readOnly?: boolean;
  secretName: string;
  shareName: string;
}

export interface VolumeCephfs {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: MagentaSecretRef;
  user?: string;
}

export interface MagentaSecretRef {
  name?: string;
}

export interface VolumeCinder {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: FriskySecretRef;
  volumeID: string;
}

export interface FriskySecretRef {
  name?: string;
}

export interface VolumeConfigMap {
  defaultMode?: number;
  items?: HilariousItem[];
  name?: string;
  optional?: boolean;
}

export interface HilariousItem {
  key: string;
  mode?: number;
  path: string;
}

export interface VolumeCSI {
  driver: string;
  fsType?: string;
  nodePublishSecretRef?: FluffyNodePublishSecretRef;
  readOnly?: boolean;
  volumeAttributes?: { [key: string]: string };
}

export interface FluffyNodePublishSecretRef {
  name?: string;
}

export interface VolumeDownwardAPI {
  defaultMode?: number;
  items?: AmbitiousItem[];
}

export interface AmbitiousItem {
  fieldRef?: HilariousFieldRef;
  mode?: number;
  path: string;
  resourceFieldRef?: HilariousResourceFieldRef;
}

export interface HilariousFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface HilariousResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface VolumeEmptyDir {
  medium?: string;
  sizeLimit?: number | string;
}

export interface VolumeEphemeral {
  volumeClaimTemplate?: FluffyVolumeClaimTemplate;
}

export interface FluffyVolumeClaimTemplate {
  metadata?: StickyMetadata;
  spec: StickySpec;
}

export interface StickyMetadata {
  annotations?: { [key: string]: string };
  finalizers?: string[];
  labels?: { [key: string]: string };
  name?: string;
  namespace?: string;
}

export interface StickySpec {
  accessModes?: string[];
  dataSource?: StickyDataSource;
  dataSourceRef?: StickyDataSourceRef;
  resources?: StickyResources;
  selector?: StickySelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: string;
  volumeName?: string;
}

export interface StickyDataSource {
  apiGroup?: string;
  kind: string;
  name: string;
}

export interface StickyDataSourceRef {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}

export interface StickyResources {
  limits?: { [key: string]: number | string };
  requests?: { [key: string]: number | string };
}

export interface StickySelector {
  matchExpressions?: MatchExpression14[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression14 {
  key: string;
  operator: string;
  values?: string[];
}

export interface VolumeFc {
  fsType?: string;
  lun?: number;
  readOnly?: boolean;
  targetWWNs?: string[];
  wwids?: string[];
}

export interface VolumeFlexVolume {
  driver: string;
  fsType?: string;
  options?: { [key: string]: string };
  readOnly?: boolean;
  secretRef?: MischievousSecretRef;
}

export interface MischievousSecretRef {
  name?: string;
}

export interface VolumeFlocker {
  datasetName?: string;
  datasetUUID?: string;
}

export interface VolumeGcePersistentDisk {
  fsType?: string;
  partition?: number;
  pdName: string;
  readOnly?: boolean;
}

export interface VolumeGitRepo {
  directory?: string;
  repository: string;
  revision?: string;
}

export interface VolumeGlusterfs {
  endpoints: string;
  path: string;
  readOnly?: boolean;
}

export interface VolumeHostPath {
  path: string;
  type?: string;
}

export interface VolumeImage {
  pullPolicy?: string;
  reference?: string;
}

export interface VolumeIscsi {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: BraggadociousSecretRef;
  targetPortal: string;
}

export interface BraggadociousSecretRef {
  name?: string;
}

export interface VolumeNFS {
  path: string;
  readOnly?: boolean;
  server: string;
}

export interface VolumePersistentVolumeClaim {
  claimName: string;
  readOnly?: boolean;
}

export interface VolumePhotonPersistentDisk {
  fsType?: string;
  pdID: string;
}

export interface VolumePortworxVolume {
  fsType?: string;
  readOnly?: boolean;
  volumeID: string;
}

export interface VolumeProjected {
  defaultMode?: number;
  sources?: FluffySource[];
}

export interface FluffySource {
  clusterTrustBundle?: FluffyClusterTrustBundle;
  configMap?: FluffyConfigMap;
  downwardAPI?: FluffyDownwardAPI;
  secret?: FluffySecret;
  serviceAccountToken?: FluffyServiceAccountToken;
}

export interface FluffyClusterTrustBundle {
  labelSelector?: MischievousLabelSelector;
  name?: string;
  optional?: boolean;
  path: string;
  signerName?: string;
}

export interface MischievousLabelSelector {
  matchExpressions?: MatchExpression15[];
  matchLabels?: { [key: string]: string };
}

export interface MatchExpression15 {
  key: string;
  operator: string;
  values?: string[];
}

export interface FluffyConfigMap {
  items?: CunningItem[];
  name?: string;
  optional?: boolean;
}

export interface CunningItem {
  key: string;
  mode?: number;
  path: string;
}

export interface FluffyDownwardAPI {
  items?: MagentaItem[];
}

export interface MagentaItem {
  fieldRef?: AmbitiousFieldRef;
  mode?: number;
  path: string;
  resourceFieldRef?: AmbitiousResourceFieldRef;
}

export interface AmbitiousFieldRef {
  apiVersion?: string;
  fieldPath: string;
}

export interface AmbitiousResourceFieldRef {
  containerName?: string;
  divisor?: number | string;
  resource: string;
}

export interface FluffySecret {
  items?: FriskyItem[];
  name?: string;
  optional?: boolean;
}

export interface FriskyItem {
  key: string;
  mode?: number;
  path: string;
}

export interface FluffyServiceAccountToken {
  audience?: string;
  expirationSeconds?: number;
  path: string;
}

export interface VolumeQuobyte {
  group?: string;
  readOnly?: boolean;
  registry: string;
  tenant?: string;
  user?: string;
  volume: string;
}

export interface VolumeRbd {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: SecretRef1;
  user?: string;
}

export interface SecretRef1 {
  name?: string;
}

export interface VolumeScaleIO {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: SecretRef2;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}

export interface SecretRef2 {
  name?: string;
}

export interface VolumeSecret {
  defaultMode?: number;
  items?: MischievousItem[];
  optional?: boolean;
  secretName?: string;
}

export interface MischievousItem {
  key: string;
  mode?: number;
  path: string;
}

export interface VolumeStorageos {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: SecretRef3;
  volumeName?: string;
  volumeNamespace?: string;
}

export interface SecretRef3 {
  name?: string;
}

export interface VolumeVsphereVolume {
  fsType?: string;
  storagePolicyID?: string;
  storagePolicyName?: string;
  volumePath: string;
}

export interface Startup {
  exec?: StartupExec;
  failureThreshold?: number;
  grpc?: StartupGrpc;
  httpGet?: StartupHTTPGet;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: StartupTCPSocket;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}

export interface StartupExec {
  command?: string[];
}

export interface StartupGrpc {
  port: number;
  service?: string;
}

export interface StartupHTTPGet {
  host?: string;
  httpHeaders?: HTTPHeader2[];
  path?: string;
  port: number | string;
  scheme?: string;
}

export interface HTTPHeader2 {
  name: string;
  value: string;
}

export interface StartupTCPSocket {
  host?: string;
  port: number | string;
}

export interface User {
  name?: string;
}

export interface TenantStatus {
  availableReplicas: number;
  certificates: Certificates;
  currentState: string;
  drivesHealing?: number;
  drivesOffline?: number;
  drivesOnline?: number;
  healthMessage?: string;
  healthStatus?: string;
  pools: StatusPool[];
  provisionedBuckets?: boolean;
  provisionedUsers?: boolean;
  revision: number;
  syncVersion: string;
  usage?: Usage;
  waitingOnReady?: Date;
  writeQuorum?: number;
}

export interface Certificates {
  autoCertEnabled?: boolean;
  customCertificates?: CustomCertificates;
}

export interface CustomCertificates {
  client?: Client[];
  minio?: Minio[];
  minioCAs?: MinioCA[];
}

export interface Client {
  certName?: string;
  domains?: string[];
  expiresIn?: string;
  expiry?: string;
  serialNo?: string;
}

export interface Minio {
  certName?: string;
  domains?: string[];
  expiresIn?: string;
  expiry?: string;
  serialNo?: string;
}

export interface MinioCA {
  certName?: string;
  domains?: string[];
  expiresIn?: string;
  expiry?: string;
  serialNo?: string;
}

export interface StatusPool {
  legacySecurityContext?: boolean;
  ssName: string;
  state: string;
}

export interface Usage {
  capacity?: number;
  rawCapacity?: number;
  rawUsage?: number;
  tiers?: Tier[];
  usage?: number;
}

export interface Tier {
  Name: string;
  totalSize: number;
  Type?: string;
}

RegisterKind(Tenant, {
  group: "minio.min.io",
  version: "v2",
  kind: "Tenant",
  plural: "tenants",
});
